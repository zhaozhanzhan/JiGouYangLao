export = underscore;
declare class underscore {
  static VERSION: string;
  static after(times: any, func: any): any;
  static all(obj: any, predicate: any, context: any): any;
  static allKeys(obj: any): any;
  static any(obj: any, predicate: any, context: any): any;
  static assign(obj: any, ...args: any[]): any;
  static before(times: any, func: any): any;
  static bind(...args: any[]): any;
  static bindAll(...args: any[]): any;
  static chain(obj: any): any;
  static chunk(array: any, count: any): any;
  static clone(obj: any): any;
  static collect(obj: any, iteratee: any, context: any): any;
  static compact(array: any): any;
  static compose(...args: any[]): any;
  static constant(value: any): any;
  static contains(obj: any, item: any, fromIndex: any, guard: any): any;
  static countBy(obj: any, iteratee: any, context: any): any;
  static create(prototype: any, props: any): any;
  static debounce(func: any, wait: any, immediate: any): any;
  static defaults(obj: any, ...args: any[]): any;
  static defer(...args: any[]): any;
  static delay(...args: any[]): any;
  static detect(obj: any, predicate: any, context: any): any;
  static difference(...args: any[]): any;
  static drop(array: any, n: any, guard: any): any;
  static each(obj: any, iteratee: any, context: any): any;
  static escape(string: any): any;
  static every(obj: any, predicate: any, context: any): any;
  static extend(obj: any, ...args: any[]): any;
  static extendOwn(obj: any, ...args: any[]): any;
  static filter(obj: any, predicate: any, context: any): any;
  static find(obj: any, predicate: any, context: any): any;
  static findIndex(array: any, predicate: any, context: any): any;
  static findKey(obj: any, predicate: any, context: any): any;
  static findLastIndex(array: any, predicate: any, context: any): any;
  static findWhere(obj: any, attrs: any): any;
  static first(array: any, n: any, guard: any): any;
  static flatten(array: any, shallow: any): any;
  static foldl(obj: any, iteratee: any, memo: any, context: any, ...args: any[]): any;
  static foldr(obj: any, iteratee: any, memo: any, context: any, ...args: any[]): any;
  static forEach(obj: any, iteratee: any, context: any): any;
  static functions(obj: any): any;
  static groupBy(obj: any, iteratee: any, context: any): any;
  static has(obj: any, path: any): any;
  static head(array: any, n: any, guard: any): any;
  static identity(value: any): any;
  static include(obj: any, item: any, fromIndex: any, guard: any): any;
  static includes(obj: any, item: any, fromIndex: any, guard: any): any;
  static indexBy(obj: any, iteratee: any, context: any): any;
  static indexOf(array: any, item: any, idx: any): any;
  static initial(array: any, n: any, guard: any): any;
  static inject(obj: any, iteratee: any, memo: any, context: any, ...args: any[]): any;
  static intersection(array: any, ...args: any[]): any;
  static invert(obj: any): any;
  static invoke(...args: any[]): any;
  static isArguments(obj: any): any;
  static isArray(p0: any): any;
  static isBoolean(obj: any): any;
  static isDate(obj: any): any;
  static isElement(obj: any): any;
  static isEmpty(obj: any): any;
  static isEqual(a: any, b: any): any;
  static isError(obj: any): any;
  static isFinite(obj: any): any;
  static isFunction(obj: any): any;
  static isMap(obj: any): any;
  static isMatch(object: any, attrs: any): any;
  static isNaN(obj: any): any;
  static isNull(obj: any): any;
  static isNumber(obj: any): any;
  static isObject(obj: any): any;
  static isRegExp(obj: any): any;
  static isSet(obj: any): any;
  static isString(obj: any): any;
  static isSymbol(obj: any): any;
  static isUndefined(obj: any): any;
  static isWeakMap(obj: any): any;
  static isWeakSet(obj: any): any;
  static iteratee(value: any, context: any): any;
  static keys(obj: any): any;
  static last(array: any, n: any, guard: any): any;
  static lastIndexOf(array: any, item: any, idx: any): any;
  static map(obj: any, iteratee: any, context: any): any;
  static mapObject(obj: any, iteratee: any, context: any): any;
  static matcher(attrs: any): any;
  static matches(attrs: any): any;
  static max(obj: any, iteratee: any, context: any): any;
  static memoize(func: any, hasher: any): any;
  static methods(obj: any): any;
  static min(obj: any, iteratee: any, context: any): any;
  static mixin(obj: any): any;
  static negate(predicate: any): any;
  static noConflict(): any;
  static noop(): void;
  static now(): any;
  static object(list: any, values: any): any;
  static omit(...args: any[]): any;
  static once(...args: any[]): any;
  static pairs(obj: any): any;
  static partition(obj: any, iteratee: any, context: any): any;
  static pick(...args: any[]): any;
  static pluck(obj: any, key: any): any;
  static property(path: any): any;
  static propertyOf(obj: any): any;
  static random(min: any, max: any): any;
  static range(start: any, stop: any, step: any): any;
  static reduce(obj: any, iteratee: any, memo: any, context: any, ...args: any[]): any;
  static reduceRight(obj: any, iteratee: any, memo: any, context: any, ...args: any[]): any;
  static reject(obj: any, predicate: any, context: any): any;
  static rest(array: any, n: any, guard: any): any;
  static restArguments(func: any, startIndex: any): any;
  static result(obj: any, path: any, fallback: any): any;
  static sample(obj: any, n: any, guard: any): any;
  static select(obj: any, predicate: any, context: any): any;
  static shuffle(obj: any): any;
  static size(obj: any): any;
  static some(obj: any, predicate: any, context: any): any;
  static sortBy(obj: any, iteratee: any, context: any): any;
  static sortedIndex(array: any, obj: any, iteratee: any, context: any): any;
  static tail(array: any, n: any, guard: any): any;
  static take(array: any, n: any, guard: any): any;
  static tap(obj: any, interceptor: any): any;
  static template(text: any, settings: any, oldSettings: any): any;
  static templateSettings: {
    escape: RegExp;
    evaluate: RegExp;
    interpolate: RegExp;
  };
  static throttle(func: any, wait: any, options: any): any;
  static times(n: any, iteratee: any, context: any): any;
  static toArray(obj: any): any;
  static unescape(string: any): any;
  static union(...args: any[]): any;
  static uniq(array: any, isSorted: any, iteratee: any, context: any): any;
  static unique(array: any, isSorted: any, iteratee: any, context: any): any;
  static uniqueId(prefix: any): any;
  static unzip(array: any): any;
  static values(obj: any): any;
  static where(obj: any, attrs: any): any;
  static without(...args: any[]): any;
  static wrap(func: any, wrapper: any): any;
  static zip(...args: any[]): any;
  constructor(obj: any);
  after(...args: any[]): any;
  all(...args: any[]): any;
  allKeys(...args: any[]): any;
  any(...args: any[]): any;
  assign(...args: any[]): any;
  before(...args: any[]): any;
  bind(...args: any[]): any;
  bindAll(...args: any[]): any;
  chain(...args: any[]): any;
  chunk(...args: any[]): any;
  clone(...args: any[]): any;
  collect(...args: any[]): any;
  compact(...args: any[]): any;
  compose(...args: any[]): any;
  concat(...args: any[]): any;
  constant(...args: any[]): any;
  contains(...args: any[]): any;
  countBy(...args: any[]): any;
  create(...args: any[]): any;
  debounce(...args: any[]): any;
  defaults(...args: any[]): any;
  defer(...args: any[]): any;
  delay(...args: any[]): any;
  detect(...args: any[]): any;
  difference(...args: any[]): any;
  drop(...args: any[]): any;
  each(...args: any[]): any;
  escape(...args: any[]): any;
  every(...args: any[]): any;
  extend(...args: any[]): any;
  extendOwn(...args: any[]): any;
  filter(...args: any[]): any;
  find(...args: any[]): any;
  findIndex(...args: any[]): any;
  findKey(...args: any[]): any;
  findLastIndex(...args: any[]): any;
  findWhere(...args: any[]): any;
  first(...args: any[]): any;
  flatten(...args: any[]): any;
  foldl(...args: any[]): any;
  foldr(...args: any[]): any;
  forEach(...args: any[]): any;
  functions(...args: any[]): any;
  groupBy(...args: any[]): any;
  has(...args: any[]): any;
  head(...args: any[]): any;
  identity(...args: any[]): any;
  include(...args: any[]): any;
  includes(...args: any[]): any;
  indexBy(...args: any[]): any;
  indexOf(...args: any[]): any;
  initial(...args: any[]): any;
  inject(...args: any[]): any;
  intersection(...args: any[]): any;
  invert(...args: any[]): any;
  invoke(...args: any[]): any;
  isArguments(...args: any[]): any;
  isArray(...args: any[]): any;
  isBoolean(...args: any[]): any;
  isDate(...args: any[]): any;
  isElement(...args: any[]): any;
  isEmpty(...args: any[]): any;
  isEqual(...args: any[]): any;
  isError(...args: any[]): any;
  isFinite(...args: any[]): any;
  isFunction(...args: any[]): any;
  isMap(...args: any[]): any;
  isMatch(...args: any[]): any;
  isNaN(...args: any[]): any;
  isNull(...args: any[]): any;
  isNumber(...args: any[]): any;
  isObject(...args: any[]): any;
  isRegExp(...args: any[]): any;
  isSet(...args: any[]): any;
  isString(...args: any[]): any;
  isSymbol(...args: any[]): any;
  isUndefined(...args: any[]): any;
  isWeakMap(...args: any[]): any;
  isWeakSet(...args: any[]): any;
  iteratee(...args: any[]): any;
  join(...args: any[]): any;
  keys(...args: any[]): any;
  last(...args: any[]): any;
  lastIndexOf(...args: any[]): any;
  map(...args: any[]): any;
  mapObject(...args: any[]): any;
  matcher(...args: any[]): any;
  matches(...args: any[]): any;
  max(...args: any[]): any;
  memoize(...args: any[]): any;
  methods(...args: any[]): any;
  min(...args: any[]): any;
  mixin(...args: any[]): any;
  negate(...args: any[]): any;
  noConflict(...args: any[]): any;
  noop(...args: any[]): any;
  now(...args: any[]): any;
  object(...args: any[]): any;
  omit(...args: any[]): any;
  once(...args: any[]): any;
  pairs(...args: any[]): any;
  partial(...args: any[]): any;
  partition(...args: any[]): any;
  pick(...args: any[]): any;
  pluck(...args: any[]): any;
  pop(...args: any[]): any;
  property(...args: any[]): any;
  propertyOf(...args: any[]): any;
  push(...args: any[]): any;
  random(...args: any[]): any;
  range(...args: any[]): any;
  reduce(...args: any[]): any;
  reduceRight(...args: any[]): any;
  reject(...args: any[]): any;
  rest(...args: any[]): any;
  restArguments(...args: any[]): any;
  result(...args: any[]): any;
  reverse(...args: any[]): any;
  sample(...args: any[]): any;
  select(...args: any[]): any;
  shift(...args: any[]): any;
  shuffle(...args: any[]): any;
  size(...args: any[]): any;
  slice(...args: any[]): any;
  some(...args: any[]): any;
  sort(...args: any[]): any;
  sortBy(...args: any[]): any;
  sortedIndex(...args: any[]): any;
  splice(...args: any[]): any;
  tail(...args: any[]): any;
  take(...args: any[]): any;
  tap(...args: any[]): any;
  template(...args: any[]): any;
  throttle(...args: any[]): any;
  times(...args: any[]): any;
  toArray(...args: any[]): any;
  toJSON(): any;
  unescape(...args: any[]): any;
  union(...args: any[]): any;
  uniq(...args: any[]): any;
  unique(...args: any[]): any;
  uniqueId(...args: any[]): any;
  unshift(...args: any[]): any;
  unzip(...args: any[]): any;
  value(): any;
  valueOf(): any;
  values(...args: any[]): any;
  where(...args: any[]): any;
  without(...args: any[]): any;
  wrap(...args: any[]): any;
  zip(...args: any[]): any;
}
declare namespace underscore {
  function partial(...args: any[]): any;
  namespace partial {
    // Circular reference from underscore.partial
    const placeholder: any;
  }
}
